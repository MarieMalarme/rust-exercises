* Data types
** Defined like this
   let var_name : <type> = value
** Example
   #+begin_src rust
     let guess: i32 = 20;
   #+end_src
** Variables and Mutability
   - In Rust all variables are immutable by default.
   - Immutable variable cannot be changed after the first assignment.
   - They can be made mutable by adding the `mut` key word to the variable declaration:
     #+begin_src rust
       let mut s = String::from("hello");
     #+end_src
** Scalar Types
   A scalar types represents a single value
*** Integers
    - [iu]size(bits)
      - i -> signed integer size (8, 16, 32, 64, 128) bits
      - u -> unsigned integer
    - isize -> depends on the architecture of the system
    - usize -> depends on the architecture of the system
    Integer literals (all number literals except the byte literal allow a type suffix such as 57u8 and underscore (_) as a visual separator such as 1_000)

    | Number lit     | Example     |
    | Decimal        | 98_222      |
    | Hex            | 0xff        |
    | Octal          | 0o77        |
    | Binary         | 0b1111_0000 |
    | Byte (u8 only) | b'A'        |

*** Floating-point numbers
    f64 or f32, default f64
*** Booleans
    true or false
*** Characters
    - Type char
    - Specified with single quotes
    - 4 bytes in size
** Compound types
    - Can group multiple values into one type
    - Rust has two primary types:
*** Tuples
    A general way of grouping together a number of values into one compound type.
    - Tuples have a fixed length
    - Comma-separated list of values inside parenthesis
    - Each position in the tuple has a type (and they don't have to be the same)
    - To get the individual values of the tuple we can use pattern matching to destructure a tuple value like this:
      #+begin_src rust
        fn main() {
            let tup = (500, 6.4, 1);
            let (x,y,z) = tup;
        }
      #+end_src
    - We can access a tuple element directly by using a period (.) followed by the index of the value we want to access. For example:
      #+begin_src rust
        fn main() {
            let x: (i32, f64, u8) = (500, 6.4, 1);
            let five_hundred = x.0;
            let six_point_four = x.1;
            let one = x.2;
        }
      #+end_src
*** Arrays
    - Arrays have a fixed length
    - An array is a single chunk of memory on the stack
    - Comma-separated list of elements of the same type inside square brackets
    - Example declaration:
      #+begin_src rust
        let a: [i32;5] = [1, 2, 3, 4, 5]; // With type annotation
        let a = [1, 2, 3, 4, 5];
        let a = [3;5]; // Produces the array [3,3,3,3,3]
      #+end_src
    - Indexing an array with array[index]
      #+begin_src rust
        fn main() {
            let a = [3, 2, 13, 5];
            println!("Second element = {}", a[1]);
        }
      #+end_src
    - Indexing an array out of bound creates a runtime error
* Formatted print
  - format!: write formatted test to String
    #+begin_src rust
      fn main() {
          let s : String = format!("{} days", 31); // now the variable s has
                                                   // the value `31 days`
      }
    #+end_src
  - print!: same as format! but the text is printed to the console (io::stdout)
  - println!: same as print! but a newline is appended
    #+begin_src rust
      fn main() {
          println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob"); // prints: `Alice, this is Bob. Bob, this is Alice`
      }
    #+end_src
  - eprint!: same as format! but the text is printed to the standard error (io::stderr)
  - eprintln!: same as eprint! but a newline is appended.
    #+begin_src rust
      fn main() {
          eprintln!(
              "{subject} {verb} {object}",
              object = "the lazy dog",
              subject = "the quick brown fox",
              verb = "jumps over"
          ); // Prints `the quick brown fox jumps over the lazy dog` to
             // standard error
      }
    #+end_src
** Examples of formatting string
   - In general the `{}` will be automatically replaced with any arguments. These will be stringified.
     #+begin_src rust
       println!("{} days", 31);
     #+end_src
   - Positional and named arguments can be used in the patterns
     #+begin_src rust
       println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob");
       println!(
           "{subject} {verb} {object}",
           object="the lazy dog",
           subject="the quick brown fox",
           verb="jumps over"
       );
     #+end_src
   - Special formatting can be specified after a `:`.
     #+begin_src rust
       println!("{} of {:b} people know binary, the other half doesn't", 1, 2);
     #+end_src
   - You can right-align text with a specified width
     #+begin_src rust
       // This will output "     1"
       println!("{number:>witdth$}", number=1, width=6);
     #+end_src
   - You can pad with extra zeroes
     #+begin_src rust
       // This will output "000001"
       println!("{number:>0width$}", number=1, width=6);
     #+end_src
   - For more info:
     [[https://doc.rust-lang.org/std/fmt/][Rust stardard formatting]]
** Formatting is controlled by Trait
  - {} is controlled by the Display trait
* Functions
  - The convention for the name of the functions is snake_case (lowercase words separated by underscores)
    #+begin_src rust
      fn my_function() {
          //body of the function
      }
    #+end_src
  - Starts with the keyword `fn`
  - Rust doesn't care where you define your functions just that they are defined somewhere
** Function parameters
   - Parameters are special variables that are part of a function's signature.
   - The concrete value of a parameter is called an argument
   - Parameters are defined like so: (name: type)
   - Example:
     #+begin_src rust
       fn print_number(n: i32*/a function parameter*/) -> i32 {
           println!("{}", n);
           n
       }
     #+end_src
** Functions Bodies Contain Statements and Expressions
   - Rust is an expression-based language
   - Statements are instructions that perform some action and do not return a value
   - Expressions evaluate to a resulting value
   - Statements end with semicolon
   - Expressions don't need semicolon
     #+begin_src rust
       fn print_number(n: i32*/a function parameter*/) {
           println!("{}", n);
       }
     #+end_src
** To Indicate the Return Value of a Function
   - Use the -> to indicate the return type
     #+begin_src rust
       fn value(n: i32) -> i32 {
           ...
       }
     #+end_src
   - Function will return the last expression type without a semicolon
   - It is possible to return before with the `return` keyword
   - Using `if` in a `let` statement
   - Because `if` is an expression, we can use it on the right side of a `let` statement
     #+begin_src rust
       let number = if condition {
           5
       } else {
           6
       };
     #+end_src
   - To use this kind of construct the returned types must be the same
     #+begin_src rust
       let number = if condition {
           5
       } else {
           "six"
       }
     #+end_src
     This code will give a compilation error
* Control Flow
** If Expressions
   - Start with the `if` keyword and it's followed by a condition.
   - The condition must have a boolean expression.
   - Allows you to branch your code depending on conditions.
   - Example:
     #+begin_src rust
       fn main() {
           let number = 3;

           if number < 5 {
               println!("The condition was true");
           } else {
               println!("The condition was false");
           }
       }
     #+end_src
** Repetition with loops
   Rust has three kinds of loops:
*** Loop
    - Execute a block of code indefinitely
    - Example:
      #+begin_src rust
        fn main() {
            loop {
                println!("again!")
            }
        }
      #+end_src
      This code will print: `again!` until the program is interrupted.
**** Returning values from loops
     - Add the value that should be returned after the break expression
     - Example:
       #+begin_src rust
         fn main() {
             let mut counter = 0;

             let result = loop {
                 counter += 1;

                 if counter == 10 {
                     break counter*2;
                 }
             };

             println!("The result is {}", result);
         }
       #+end_src
*** While
    - Conditional loop
    - While a condition is `true` the loop runs; otherwise it exits the loop
    - Example:
      #+begin_src rust
        fn main() {
            let mut number = 3;

            while number != 0 {
                println!("{}!", number);

                number -= 1;
            }

            println!("LIFTOFF!!!");
        }
      #+end_src
*** For
    - Loop through a collection with `for`
    - Example:
      #+begin_src rust
        fn main() {
            let a = [10, 20, 30, 40, 50];
            for element in a.iter() { // a.iter returns an iterator for the array
                println!("the value is: {}", element);
            }
        }
      #+end_src
      - Increases safety and speed (preferred over `while`)
      - To loop through a range of numbers, instead of using a `while` loop, it's better to use a `Range`.
        #+begin_src rust
          fn main() {
              for number in (1..4).rev() { // (1..4) creates an iterator for the numbers 1 to 3
                  //and the method rev() reverses the order
                  println!("{}!", number);
              }
              println!("LIFTOFF!!!");
          }
        #+end_src
* Understanding Ownership
  - It's the mechanism that enables Rust to make memory safety guarantees without needing a garbage collector.
  - In Rust memory is manage through a system of ownership with a set of rules that the compiler checks at compile time.
  - Keeping track of what part of the code is using what part of the heap, minimizing the amount of duplicated data on the heap and cleaning up unused data on the heap so you don't run out of space are all problems that ownership addresses.
** The Heap and the Stack
*** The Stack
    - It's a special region of the computer's memory that stores temporary variables created by each function (including the main function)
    - The stack stores values in the order it gets them and removes them in the opposite order (last-in first-out)
    - All data in the stack most have a known fixed size
    - When a function exits all the variables pushed into the stack are freed
    - Pushing to the stack is faster than allocating memory on the heap
*** The Heap
    - The heap is a region of the computer's memory that is not automatically managed for you, and it's not as tightly managed by the CPU.
    - The heap is less organized
    - When you put a data in the heap:
      - you request a certain amount of space
      - the operating system finds an empty space that is big enough
      - marks it as being in use and returns a pointer to it.
    - Accessing data in the heap is slower than accessing data on the stack
** Ownership Rules
   - Each value in Rust has a variable that's called its owner.
   - There can be only one owner at a time.
   - When the owner goes out of scope, the value will be dropped.
** Variable Scope
   - A variable it's valid when comes into scope.
   - It remains valid until it goes out of scope.
   - Example:
     #+begin_src rust
       {// s in not valid here, it's not yet declared
           let s = "hello"; // s is valid from this point forward

           // use variable s
       }// this scope is now over, and s is no longer valid
     #+end_src
** Memory and Allocation
   - For types that are stored in the stack (for types that implement the `Copy` trait, i.e., scalar types and tuples that only contain scalar types) Rust copies the value when a new variable is assigned to that variable
   - Example:
     #+begin_src rust
       let x = 5;
       let y = x;
     #+end_src
     After this both x and y are valid and both evaluate to the value 5
   - For types that are stored in the heap Rust just moves the value
   - Example:
     #+begin_src rust
       let s1 = String::from("Hello");
       let s2 = s1;
     #+end_src
     After this operation the value of s1 was moved to s2 and s1 is no longer valid
   - For types that are stored in the stack it's possible to copy the value using the clone method
   - Example:
     #+begin_src rust
       let s1 = String::from("hello");
       let s2 = s1.clone();

       println!("s1 = {}, s2 = {}", s1, s2)
     #+end_src
** Ownership and Functions
   - It works exactly the same way as reassigning a value
   - If a variable of a type that is stored in the heap is passed to a function, then the function takes ownership of that value
     #+begin_src rust
       fn main() {
           let s = String::from("hello"); // s comes into scope
           takes_ownership(s);            // s's value moves into the
                                          // function so is no longer valid here

           let x = 5;
           makes_copy(x); //x would move into the function,
                          // but i32 implement the `Copy`, so it's okay to still
                          // use x afterward
       }

       fn takes_ownership(some_string: String) {
           println!("{}", some_string);
       }

       fn makes_copy(some_integer: i32) {
           println!("{}", some_interger);
       }
     #+end_src
   - After, the function can return ownership by returning the value (if you don't want that data to be freed after finishing the function).
** References and Borrowing
*** Definition
    - A reference represents the address in memory of a variable
    - A value is referenced by the `&` operator
      #+begin_src rust
        // Declaring a pointer to the integer 5
        let x = &5;
        let y = &mut 4;
      #+end_src
    - It's possible to use the `ref` keyword to create a reference
      #+begin_src rust
        let ref x = 4;
        // And a mutable reference with
        let mut ref s = String::from("hello");
      #+end_src
    - They allow you to refer to a type without taking ownership of it
    - References can be made mutable to modify the value without taking ownership of it
    - References are immutable by default
*** Rules of References
    - At any time, you can have either one mutable reference or any number of immutable references.
    - References must always be valid.
*** Use cases
   - When a reference is passed then we say that the variable is borrowed.
      #+begin_src rust
        fn main() {
            let s1 = String::from("hello");

            let len = calculate_length(&s1);

            println!("length of {} is {}", s1, len); // s1 is valid here
                                                     // because calculate_length only borrows s1
        }

        fn calculate_length(s: &String) -> usize {
            s.len();
        }
      #+end_src
   - Reference can be made mutable to allow to change it's value without taking ownership of the value:
      #+begin_src rust
        fn main() {
            let mut s = String::from("hello");
            change(&mut s);
            // s is still valid here and the value is "hello, world"
            println!("s = {}", s);
        }

        fn change(some_string: &mut String) {
            some_string.push_str(", world");
        }
      #+end_src
* String Slices
   - A string slice is a reference to part of a string, and it looks like this:
     #+begin_src rust
       let s = String::from("hello world");

       let hello = &s[0..5];
       let world = &s[6..11];
     #+end_src
   - We can create slices using a range within brackets by specifying [starting_index..ending_index]
     - where starting_index is the first position in the slice and ending_index is one more than the last position in the slice.
   - With Rust's `..` range syntax if you want to start at the first index (zero), you can drop the value before the two periods. In other words, these are equal:
     #+begin_src rust
       let s = String::from("hello");

       let slice = &s[0..2];
       let slice = &s[..2];
     #+end_src
   - By the same token , if your slice includes the last byte of the `String`
     #+begin_src rust
       let s = String::from("hello");

       let len = s.len();

       let slice = &s[3..len];
       let slice = &s[3..];
     #+end_src
   - You can also drop both values to take a slice of the entire string. So these are equal:
     #+begin_src rust
       let s = String::from("hello");

       let len = s.len();

       let slice = &[0..len];
       let slice = &[..];
     #+end_src
   - String Literals are String Slices
   - Using &str allows both &str and &String.
     #+begin_src rust
       fn main() {
           let my_string = String::from("hello world");

           // first_word works on slices of `String`s
           let word = first_word(&my_string[..]);

           let my_string_literal = "hello world";

           // first_word works on slices of string literals
           let word = first_word(&my_string_literal[..]);

           // Because string literals *are* string slices already,
           // this works too, without the slice syntax!
           let word = first_word(my_string_literal);
       }

       fn first_word(s: &str) -> &str {
           ...
       }
     #+end_src
* Structs
** Defining and Initializing Structs
  - Let's see an example of a struct definition
    #+begin_src rust
      struct User {
          username: String,
          email: String,
          sign_in_count: i64,
          active: bool,
      }
    #+end_src
    - Initialization:
      #+begin_src rust
        let user1 = User {
            email: String::from("someone@something.com"),
            username: String::from("name"),
            active: true,
            sign_in_count: 1,
        };
      #+end_src
    - When a variable has the same name as the field of the structure you can use the shorthand notation:
      #+begin_src rust
        fn build_user(email: String, username: String) -> User {
            User {
                email,
                username,
                active: true,
                sign_in_count: 1,
            }
        }
      #+end_src
    - The syntax .. specifies that the remaining fields not explicitly set should have the same value as the field in the given instance
      #+begin_src rust
        let user2 = User {
            email: String::from("another@example.com"),
            username: String::from("anotherusername567"),
            ..user1
        }
      #+end_src
** Printing
   - To print a struct we can use the following annotation before the type definition to be able to use "{:?}" or {:#?} print the content with the macro println! 
	 #+begin_src rust
	   #[derive(Debug)]
		   struct Rectangle {
		   width: u32,
		   height: u32,
	   }

	   fn main() {
		   let rect1 = Rectangle {
			   width: 30,
			   height: 50,
		   };

		   println!(
			   "Rectangle1 = {:?}",
			   rect1
		   );
	   }
	 #+end_src
** Method syntax
   - Methods are defined in the context of a struct, enums or trait object.
   - They're first parameter is `self` which represents the instance of the structure the method is being called on.
   - Example:
	 #+begin_src rust
	   #[derive(Debug)]
	   struct Rectangle {
		   width: u32,
		   height: u32,
	   }

	   impl Rectangle {
		   fn area(&self) -> u32 {
			   self.width * self.height
		   }
	   }

	   fn main() {
		   let rect1 = Rectangle {
			   width: 30,
			   height: 50,
		   };

		   println!(
			   "The area of the rectangle is {} square pixels.",
			   rect1.area()
		   );
	   }
	 #+end_src
   - To define a method we start an impl (implementation) block.
   - You can use &self, &mut self, and self as any other parameter.
*** Automatic reference and dereferencing
	- When you call a method width `object.something()` Rust automatically adds in &, &mut or * so `object` matches the signature of the method.
*** Associated functions
	- A function defined inside an `impl` block, but it doesn't receive self as the first argument is called an associated function.
	- Is called in the program using the namespace of the structure and the `::` operator like we saw in the String::from function.
*** Each structure is allowed to have multiple impl blocks
* Enums and parent matching
** Defining an enum
   #+begin_src rust
	 enum IpAddrKind {
		 v4,
		 v6,
	 }

	 // enum values
	 let four = IpAddrKind::v4;
	 let six = IpAddrKind::v6;

	 // We can associate data (of any type) to an enum like this
	 enum IpAddr {
		 v4(String),
		 v6(String),
	 }
   #+end_src
   - Another example of enum
	 #+begin_src rust
	   enum Message {
		   Quit,
		   Move {x: i32, y: i32},
		   Write(String),
		   ChangeColor(i32,i32,i32),
	   }
	 #+end_src
** The option Enum and its advantages over null values
   #+begin_src rust
	 enum Option<T> {
		 Some(T),
		 None,
	 }

	 let some_string = Some("a string");
	 let absent_number: Option<i32> = None
   #+end_src
   If we use None rather than Some we need to tell Rust what type of Option<T> methods and associated functions
** The `match` control flow operator
   `match`allows you to compare a value against a series of patterns and then execute code base in which pattern matches.
   - Example:
	 #+begin_src rust
	   enum Coin {
		   Penny,
		   Nickel,
		   Dime,
		   Quarter,
	   }

	   fn value_in_cents(coin: Coin) -> u8 {
		   match coin {
			   Coin::Penny => 1,
			   Coin::Nickel => 5,
			   Coin::Dime => 10,
			   Coin::Quarter => 25,
		   }
	   }
	 #+end_src
   - `match` is exhaustive (it forces you to handle every case)
   - For a single pattern matching use `if let`
	 #+begin_src rust
	   if let Some(3) = some_u8_value {
		   println!("three");
	   }

	   // Equivalent to

	   match some_u8_value {
		   Some(3) => println!("three"),
		   _ => (),
	   }
	 #+end_src
* Common Collections
  Rust's standard library includes a number of very useful data structures called collections. Most other data types represent one specific value, but collections can contain multiple values.
  - The data of these collections point to is stored in the heap, which means the amount of data does not need to be known at compile time and can grow or shrink as the program runs.
** Vectors:
   - Type Vec<T>
   - Allows you to store a variable number of values next to each other.
*** Creating a New Vector
	#+begin_src rust
	  let v: Vec<i32> = Vec::new();
	#+end_src
	- It's more common to create a vector width values inside
	- In that case you don't need to annotate the type and Rust provides the `vec` macro
	  #+begin_src rust
		let v = vec![1,2,3];
	  #+end_src
	- Because we've given initial i32 values, Rust can infer the type of v is Vec<i32>, and the type annotation isn't necessary.
*** Updating a Vector
	- You can use the push method
	  #+begin_src rust
		let mut v = Vec::new();

		v.push(5);
		v.push(6);
		v.push(7);
		v.push(8);
	  #+end_src
	- As any variable, if we want to be able to change its value, we need to make it mutable using the mut keyword.
	- The numbers we place inside are all of type i32, and Rust infers this from the data, so we don't need the Vec<i32> annotation.
	- When the vector gets dropped, all f its contents are also dropped, meaning hose integers it holds will be cleaned up.
	- This may seem like a straightforward point but can got a bit more complicated when you start to introduce references to the elements of the vector
*** Reading Elements of Vectors
	- Indexing syntax
	  #+begin_src rust
		let v = vec![1, 2, 3, 4, 5];
		let third: &i32 = &v[2];
		// selects the third element of the vector v
	  #+end_src
	- The get method
	#+begin_src rust
	  let v = vec![1, 2, 3, 4, 5];

	  match v.get(2) {
		  Some(third) => println!("The third element is {}", third),
		  None => println!("There is no third element."),
	  }
	#+end_src
*** Choosing which one to use
	- If you try to index an element of the vector that doesn't exist with the indexing syntax the program will panic
	- Meanwhile using the get method will return `None` and logic can be added to handle what happens when an index out of range is accessed
	- For situations where is normal to access the wrong position like in a user interface where the user must insert the index is better to give one opportunity to introduce the index and telling them what the index range must be it's a better option that panicking
	- For cases where an index out of range implies an error of logic that the program cannot come back from then the best option is to use the indexing syntax
	- The reference rules apply for vectors too
	#+begin_src rust
	  let mut v = vec![1, 2, 3, 4, 5];
	  let first = &v[0];
	  v.push(6);
	  println!("The first element is {}", first);
	#+end_src
	Compiling this code will result in a compile error.
** Strings:
   - Is a collection of characters encoded in UTF-8.
   - String are implemented as a collection of bytes, plus some methods to provide useful functionality when those byte are interpreted as text.
   - What is a String? Usually "string" is referring to the both string slices and `String` slice.
	 - Rust has only one string type in the core language, which is the string slice `str`.
	 - The `String` type, which is provided by Rust's standard library.
*** Creating a New String
	#+begin_src rust
	  let mut s = String::new();
	#+end_src	
*** Creating a String from a string slice
	#+begin_src rust
	  let data = "initial contents";
	  let s = data.to_string();

	  let s = "initial contents".to_string();

	  let s = String::from("initial contents");
	#+end_src
*** Updating a string
	#+begin_src rust
	  let mut s = String::from("foo");
	  s.push_str("bar");

	  // Pushing a character
	  let mut s = String::from("lo");
	  s.push('l');
	#+end_src
**** Concatenation with the + operator or the format! macro
	 #+begin_src rust
	   let s1 = String::from("Hello, ");
	   let s2 = String::from("world!");
	   let s3 = s1 + &s2; // note s1 has been moved here and can no lnger be used
	 #+end_src
	 If we concatenate multiple string multiple strings, the behavior of the + operator gets unwieldy:
	 #+begin_src rust
	   let s1 = String::from("tic");
	   let s2 = String::from("tac");
	   let s3 = String::from("toe");

	   let s = s1 + "-" + &s2 + "-" + &s3;
	 #+end_src
	For complicated string we can use the format! macro.
	#+begin_src rust
	  let s1 = String::from("tic");
	  let s2 = String::from("tac");
	  let s3 = String::from("toe");

	  let s = format!("{}-{}-{}", s1, s2, s3);
	#+end_src
**** Indexing into strings is not allowed
	 #+begin_src rust
	   let s1 = String::from("hello");
	   let h = s1[0];
	 #+end_src
	 Will produce a compilation error.
	 Internal Representation
**** Internal Representation 
	 - A string is a wrapper over Vec<u8>.
**** Slicing String
	 - You can use [] with a range to create a string slice containing particular bytes:
	 #+begin_src rust
	   let hello = "Здравствуйте";
	   let s = &hello[0..2];
	   // Because the first character is 2 bytes long s has the value "З" and it's a string slice
	 #+end_src
**** Methods for iterating over strings
	 - s.chars();
	 #+begin_src rust
	   for c in "नमस्ते".chars() {
		   println!("{}", c);
	   }
	   // will print the following:
	   // न
	   // म
	   // स
	   // ्
	   // त
	   // े
	 #+end_src
	 - s.bytes();
	 #+begin_src rust
	   for b in "नमस्ते".bytes() {
		   println!("{}", b);
	   }
	   // will print:
	   224
	   164
	   // --snip--
	   165
	   135
	 #+end_src
** Hash maps
   Allows you to associate a value with a particular key. It's a particular implementation of the more general data structure called a map.
   - Type HashMap<K, V> stores a mapping of keys of type K to values of type V.
*** Creating a new Hash Map
	#+begin_src rust
	  use std::collections::HashMap;

	  let mut scores = HashMap::new();

	  scores.insert(String::from("Blue"), 10);
	  scores.insert(String::from("Yellow"), 50);
	#+end_src
	Like vectors, hash maps are homogeneous: all of the keys must have the same type and all of the values must have the same type.
**** Creating a hash map by using iterators and the collect method
	 - The `collect` method gathers data into a number of collections types, including HashMap.
	 #+begin_src rust
	   use std::collections::HashMap;

	   let teams = vec![String::from("Blue"), String::from("Yellow")];
	   let initial_scores = vec![10, 50];

	   let mut scores: HashMap<_, _> = teams.into_iter().zip(initial_scores.into_iter()).collect();
	   // zip creates a vector of tuples where "Blue" is paired with 10, and so forth.
	   // then the collect method turns that vector of tuples into a hash map
	   // The type annotation HashMap<_, _> is needed because it's possible
	   // to collect into many different data structures and Rust doesn't
	   // know which you want unless you specify. 
	 #+end_src
*** Hash maps and ownership
	For types that implement the Copy trait, like i32, the values are copied into the hash map. For owned values like String, the values are moved and the hash map will be the owner of those values.
*** Accessing values in a hash map
	We can get a value out of the hash map by providing its key to the get method.
	#+begin_src rust
	  use std::collections::HashMap;

	  let mut scores = HashMap::new();

	  scores.insert(String::from("Blue"), 10);
	  scores.insert(String::from("Yellow"), 50);

	  let team_name = String::from("Blue");
	  let score = scores.get(&team_name);
	#+end_src
	The method get returns an Option<&V>:
	- If the value associated to the key doesn't exist the get returns None
	- Otherwise returns Some(&value), in this case Some(&10).

	We can iterate through over each key/value pair in a hash map in a similar manner as we do with vectors, using a for loop:
	#+begin_src rust
	  use std::collections::HashMap;

	  let mut scores = HashMap::new();

	  scores.insert(String::from("Blue"), 10);
	  scores.insert(String::from( "Yellow" ), 50);

	  for (key, value) in &scores {
		  println!("{}: {}", key, value);
	  }
	#+end_src
*** Updating a HashMap
	- Overwriting a Value
	  Use the `insert` method.
	#+begin_src rust
	  fn main() {
		  use std::collections::HashMap;

		  let mut scores = HashMap::new();

		  scores.insert(String::from("Blue"), 10);
		  scores.insert(String::from("Blue"), 25);

		  println!("{:?}", scores);
	  }

	#+end_src
	- Only inserting a Value If the Key Has no Value
	  Use the `entry` method to get the entry of the given key in the map and `or_insert` method to insert if the element doesn't exist.
	#+begin_src rust
	  fn main() {
		  use std::collections::HashMap;

		  let mut scores = HashMap::new();
		  scores.insert(String::from("Blue"), 10);

		  scores.entry(String::from("Yellow")).or_insert(50);
		  scores.entry(String::from("Blue")).or_insert(50);

		  println!("{:?}", scores);
	  }
	#+end_src
	- Updating a Value Based on the Old Value
	  The `or_insert` method returns a mutable reference to the value
	#+begin_src rust
	  fn main() {
		  use std::collections::HashMap;

		  let text = "hello world wonderful world";

		  let mut map = HashMap::new();

		  for word in text.split_whitespace() {
			  let count = map.entry(word).or_insert(0);
			  *count += 1;
		  }

		  println!("{:?}", map);
	  }
	#+end_src
** More Collections [[https://doc.rust-lang.org/stable/std/collections/index.html][see the documentation]]
