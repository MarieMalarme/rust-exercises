* Data types
** Defined like this
   let var_name : <type> = value
** Example
   #+begin_src rust
     let guess: i32 = 20;
   #+end_src
** Variables and Mutability
   - In Rust all variables are immutable by default.
   - Immutable variable cannot be changed after the first assignment.
   - They can be made mutable by adding the `mut` key word to the variable declaration:
     #+begin_src rust
       let mut s = String::from("hello");
     #+end_src
** Scalar Types
   A scalar types represents a single value
*** Integers
    - [iu]size(bits)
      - i -> signed integer size (8, 16, 32, 64, 128) bits
      - u -> unsigned integer
    - isize -> depends on the architecture of the system
    - usize -> depends on the architecture of the system
    Integer literals (all number literals except the byte literal allow a type suffix such as 57u8 and underscore (_) as a visual separator such as 1_000)

    | Number lit     | Example     |
    | Decimal        | 98_222      |
    | Hex            | 0xff        |
    | Octal          | 0o77        |
    | Binary         | 0b1111_0000 |
    | Byte (u8 only) | b'A'        |

*** Floating-point numbers
    f64 or f32, default f64
*** Booleans
    true or false
*** Characters
    - Type char
    - Specified with single quotes
    - 4 bytes in size
** Compound types
    - Can group multiple values into one type
    - Rust has two primary types:
*** Tuples
    A general way of grouping together a number of values into one compound type.
    - Tuples have a fixed length
    - Comma-separated list of values inside parenthesis
    - Each position in the tuple has a type (and they don't have to be the same)
    - To get the individual values of the tuple we can use pattern matching to destructure a tuple value like this:
      #+begin_src rust
        fn main() {
            let tup = (500, 6.4, 1);
            let (x,y,z) = tup;
        }
      #+end_src
    - We can access a tuple element directly by using a period (.) followed by the index of the value we want to access. For example:
      #+begin_src rust
        fn main() {
            let x: (i32, f64, u8) = (500, 6.4, 1);
            let five_hundred = x.0;
            let six_point_four = x.1;
            let one = x.2;
        }
      #+end_src
*** Arrays
    - Arrays have a fixed length
    - An array is a single chunk of memory on the stack
    - Comma-separated list of elements of the same type inside square brackets
    - Example declaration:
      #+begin_src rust
        let a: [i32;5] = [1, 2, 3, 4, 5]; // With type annotation
        let a = [1, 2, 3, 4, 5];
        let a = [3;5]; // Produces the array [3,3,3,3,3]
      #+end_src
    - Indexing an array with array[index]
      #+begin_src rust
        fn main() {
            let a = [3, 2, 13, 5];
            println!("Second element = {}", a[1]);
        }
      #+end_src
    - Indexing an array out of bound creates a runtime error
* Formatted print
  - format!: write formatted test to String
    #+begin_src rust
      fn main() {
          let s : String = format!("{} days", 31); // now the variable s has
                                                   // the value `31 days`
      }
    #+end_src
  - print!: same as format! but the text is printed to the console (io::stdout)
  - println!: same as print! but a newline is appended
    #+begin_src rust
      fn main() {
          println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob"); // prints: `Alice, this is Bob. Bob, this is Alice`
      }
    #+end_src
  - eprint!: same as format! but the text is printed to the standard error (io::stderr)
  - eprintln!: same as eprint! but a newline is appended.
    #+begin_src rust
      fn main() {
          eprintln!(
              "{subject} {verb} {object}",
              object = "the lazy dog",
              subject = "the quick brown fox",
              verb = "jumps over"
          ); // Prints `the quick brown fox jumps over the lazy dog` to
             // standard error
      }
    #+end_src
** Examples of formatting string
   - In general the `{}` will be automatically replaced with any arguments. These will be stringified.
     #+begin_src rust
       println!("{} days", 31);
     #+end_src
   - Positional and named arguments can be used in the patterns
     #+begin_src rust
       println!("{0}, this is {1}. {1}, this is {0}", "Alice", "Bob");
       println!(
           "{subject} {verb} {object}",
           object="the lazy dog",
           subject="the quick brown fox",
           verb="jumps over"
       );
     #+end_src
   - Special formatting can be specified after a `:`.
     #+begin_src rust
       println!("{} of {:b} people know binary, the other half doesn't", 1, 2);
     #+end_src
   - You can right-align text with a specified width
     #+begin_src rust
       // This will output "     1"
       println!("{number:>witdth$}", number=1, width=6);
     #+end_src
   - You can pad with extra zeroes
     #+begin_src rust
       // This will output "000001"
       println!("{number:>0width$}", number=1, width=6);
     #+end_src
   - For more info:
     [[https://doc.rust-lang.org/std/fmt/][Rust stardard formatting]]
** Formatting is controlled by Trait
  - {} is controlled by the Display trait
* Functions
  - The convention for the name of the functions is snake_case (lowercase words separated by underscores)
    #+begin_src rust
      fn my_function() {
          //body of the function
      }
    #+end_src
  - Starts with the keyword `fn`
  - Rust doesn't care where you define your functions just that they are defined somewhere
** Function parameters
   - Parameters are special variables that are part of a function's signature.
   - The concrete value of a parameter is called an argument
   - Parameters are defined like so: (name: type)
   - Example:
     #+begin_src rust
       fn print_number(n: i32*/a function parameter*/) -> i32 {
           println!("{}", n);
           n
       }
     #+end_src
** Functions Bodies Contain Statements and Expressions
   - Rust is an expression-based language
   - Statements are instructions that perform some action and do not return a value
   - Expressions evaluate to a resulting value
   - Statements end with semicolon
   - Expressions don't need semicolon
     #+begin_src rust
       fn print_number(n: i32*/a function parameter*/) {
           println!("{}", n);
       }
     #+end_src
** To Indicate the Return Value of a Function
   - Use the -> to indicate the return type
     #+begin_src rust
       fn value(n: i32) -> i32 {
           ...
       }
     #+end_src
   - Function will return the last expression type without a semicolon
   - It is possible to return before with the `return` keyword
   - Using `if` in a `let` statement
   - Because `if` is an expression, we can use it on the right side of a `let` statement
     #+begin_src rust
       let number = if condition {
           5
       } else {
           6
       };
     #+end_src
   - To use this kind of construct the returned types must be the same
     #+begin_src rust
       let number = if condition {
           5
       } else {
           "six"
       }
     #+end_src
     This code will give a compilation error
* Control Flow
** If Expressions
   - Start with the `if` keyword and it's followed by a condition.
   - The condition must have a boolean expression.
   - Allows you to branch your code depending on conditions.
   - Example:
     #+begin_src rust
       fn main() {
           let number = 3;

           if number < 5 {
               println!("The condition was true");
           } else {
               println!("The condition was false");
           }
       }
     #+end_src
** Repetition with loops
   Rust has three kinds of loops:
*** Loop
    - Execute a block of code indefinitely
    - Example:
      #+begin_src rust
        fn main() {
            loop {
                println!("again!")
            }
        }
      #+end_src
      This code will print: `again!` until the program is interrupted.
**** Returning values from loops
     - Add the value that should be returned after the break expression
     - Example:
       #+begin_src rust
         fn main() {
             let mut counter = 0;

             let result = loop {
                 counter += 1;

                 if counter == 10 {
                     break counter*2;
                 }
             };

             println!("The result is {}", result);
         }
       #+end_src
*** While
    - Conditional loop
    - While a condition is `true` the loop runs; otherwise it exits the loop
    - Example:
      #+begin_src rust
        fn main() {
            let mut number = 3;

            while number != 0 {
                println!("{}!", number);

                number -= 1;
            }

            println!("LIFTOFF!!!");
        }
      #+end_src
*** For
    - Loop through a collection with `for`
    - Example:
      #+begin_src rust
        fn main() {
            let a = [10, 20, 30, 40, 50];
            for element in a.iter() { // a.iter returns an iterator for the array
                println!("the value is: {}", element);
            }
        }
      #+end_src
      - Increases safety and speed (preferred over `while`)
      - To loop through a range of numbers, instead of using a `while` loop, it's better to use a `Range`.
        #+begin_src rust
          fn main() {
              for number in (1..4).rev() { // (1..4) creates an iterator for the numbers 1 to 3
                  //and the method rev() reverses the order
                  println!("{}!", number);
              }
              println!("LIFTOFF!!!");
          }
        #+end_src
* Understanding Ownership
  - It's the mechanism that enables Rust to make memory safety guarantees without needing a garbage collector.
  - In Rust memory is manage through a system of ownership with a set of rules that the compiler checks at compile time.
  - Keeping track of what part of the code is using what part of the heap, minimizing the amount of duplicated data on the heap and cleaning up unused data on the heap so you don't run out of space are all problems that ownership addresses.
** The Heap and the Stack
*** The Stack
    - It's a special region of the computer's memory that stores temporary variables created by each function (including the main function)
    - The stack stores values in the order it gets them and removes them in the opposite order (last-in first-out)
    - All data in the stack most have a known fixed size
    - When a function exits all the variables pushed into the stack are freed
    - Pushing to the stack is faster than allocating memory on the heap
*** The Heap
    - The heap is a region of the computer's memory that is not automatically managed for you, and it's not as tightly managed by the CPU.
    - The heap is less organized
    - When you put a data in the heap:
      - you request a certain amount of space
      - the operating system finds an empty space that is big enough
      - marks it as being in use and returns a pointer to it.
    - Accessing data in the heap is slower than accessing data on the stack
** Ownership Rules
   - Each value in Rust has a variable that's called its owner.
   - There can be only one owner at a time.
   - When the owner goes out of scope, the value will be dropped.
** Variable Scope
   - A variable it's valid when comes into scope.
   - It remains valid until it goes out of scope.
   - Example:
     #+begin_src rust
       {// s in not valid here, it's not yet declared
           let s = "hello"; // s is valid from this point forward

           // use variable s
       }// this scope is now over, and s is no longer valid
     #+end_src
** Memory and Allocation
   - For types that are stored in the stack (for types that implement the `Copy` trait, i.e., scalar types and tuples that only contain scalar types) Rust copies the value when a new variable is assigned to that variable
   - Example:
     #+begin_src rust
       let x = 5;
       let y = x;
     #+end_src
     After this both x and y are valid and both evaluate to the value 5
   - For types that are stored in the heap Rust just moves the value
   - Example:
     #+begin_src rust
       let s1 = String::from("Hello");
       let s2 = s1;
     #+end_src
     After this operation the value of s1 was moved to s2 and s1 is no longer valid
   - For types that are stored in the stack it's possible to copy the value using the clone method
   - Example:
     #+begin_src rust
       let s1 = String::from("hello");
       let s2 = s1.clone();

       println!("s1 = {}, s2 = {}", s1, s2)
     #+end_src
** Ownership and Functions
   - It works exactly the same way as reassigning a value
   - If a variable of a type that is stored in the heap is passed to a function, then the function takes ownership of that value
     #+begin_src rust
       fn main() {
           let s = String::from("hello"); // s comes into scope
           takes_ownership(s);            // s's value moves into the
                                          // function so is no longer valid here

           let x = 5;
           makes_copy(x); //x would move into the function,
                          // but i32 implement the `Copy`, so it's okay to still
                          // use x afterward
       }

       fn takes_ownership(some_string: String) {
           println!("{}", some_string);
       }

       fn makes_copy(some_integer: i32) {
           println!("{}", some_interger);
       }
     #+end_src
   - After, the function can return ownership by returning the value (if you don't want that data to be freed after finishing the function).
** References and Borrowing
*** Definition
    - A reference represents the address in memory of a variable
    - A value is referenced by the `&` operator
      #+begin_src rust
        // Declaring a pointer to the integer 5
        let x = &5;
        let y = &mut 4;
      #+end_src
    - It's possible to use the `ref` keyword to create a reference
      #+begin_src rust
        let ref x = 4;
        // And a mutable reference with
        let mut ref s = String::from("hello");
      #+end_src
    - They allow you to refer to a type without taking ownership of it
    - References can be made mutable to modify the value without taking ownership of it
    - References are immutable by default
*** Rules of References
    - At any time, you can have either one mutable reference or any number of immutable references.
    - References must always be valid.
*** Use cases
   - When a reference is passed then we say that the variable is borrowed.
      #+begin_src rust
        fn main() {
            let s1 = String::from("hello");

            let len = calculate_length(&s1);

            println!("length of {} is {}", s1, len); // s1 is valid here
                                                     // because calculate_length only borrows s1
        }

        fn calculate_length(s: &String) -> usize {
            s.len();
        }
      #+end_src
   - Reference can be made mutable to allow to change it's value without taking ownership of the value:
      #+begin_src rust
        fn main() {
            let mut s = String::from("hello");
            change(&mut s);
            // s is still valid here and the value is "hello, world"
            println!("s = {}", s);
        }

        fn change(some_string: &mut String) {
            some_string.push_str(", world");
        }
      #+end_src
* String Slices
   - A string slice is a reference to part of a string, and it looks like this:
     #+begin_src rust
       let s = String::from("hello world");

       let hello = &s[0..5];
       let world = &s[6..11];
     #+end_src
   - We can create slices using a range within brackets by specifying [starting_index..ending_index]
     - where starting_index is the first position in the slice and ending_index is one more than the last position in the slice.
   - With Rust's `..` range syntax if you want to start at the first index (zero), you can drop the value before the two periods. In other words, these are equal:
     #+begin_src rust
       let s = String::from("hello");

       let slice = &s[0..2];
       let slice = &s[..2];
     #+end_src
   - By the same token , if your slice includes the last byte of the `String`
     #+begin_src rust
       let s = String::from("hello");

       let len = s.len();

       let slice = &s[3..len];
       let slice = &s[3..];
     #+end_src
   - You can also drop both values to take a slice of the entire string. So these are equal:
     #+begin_src rust
       let s = String::from("hello");

       let len = s.len();

       let slice = &[0..len];
       let slice = &[..];
     #+end_src
   - String Literals are String Slices
   - Using &str allows both &str and &String.
     #+begin_src rust
       fn main() {
           let my_string = String::from("hello world");

           // first_word works on slices of `String`s
           let word = first_word(&my_string[..]);

           let my_string_literal = "hello world";

           // first_word works on slices of string literals
           let word = first_word(&my_string_literal[..]);

           // Because string literals *are* string slices already,
           // this works too, without the slice syntax!
           let word = first_word(my_string_literal);
       }

       fn first_word(s: &str) -> &str {
           ...
       }
     #+end_src
* Structs
** Defining and Initializing Structs
  - Let's see an example of a struct definition
    #+begin_src rust
      struct User {
          username: String,
          email: String,
          sign_in_count: i64,
          active: bool,
      }
    #+end_src
    - Initialization:
      #+begin_src rust
        let user1 = User {
            email: String::from("someone@something.com"),
            username: String::from("name"),
            active: true,
            sign_in_count: 1,
        };
      #+end_src
    - When a variable has the same name as the field of the structure you can use the shorthand notation:
      #+begin_src rust
        fn build_user(email: String, username: String) -> User {
            User {
                email,
                username,
                active: true,
                sign_in_count: 1,
            }
        }
      #+end_src
    - The syntax .. specifies that the remaining fields not explicitly set should have the same value as the field in the given instance
      #+begin_src rust
        let user2 = User {
            email: String::from("another@example.com"),
            username: String::from("anotherusername567"),
            ..user1
        }
      #+end_src
** Printing
   - To print a struct we can use the following annotation before the type definition to be able to use "{:?}" or {:#?} print the content with the macro println! 
	 #+begin_src rust
	   #[derive(Debug)]
		   struct Rectangle {
		   width: u32,
		   height: u32,
	   }

	   fn main() {
		   let rect1 = Rectangle {
			   width: 30,
			   height: 50,
		   };

		   println!(
			   "Rectangle1 = {:?}",
			   rect1
		   );
	   }
	 #+end_src
** Method syntax
   - Methods are defined in the context of a struct, enums or trait object.
   - They're first parameter is `self` which represents the instance of the structure the method is being called on.
   - Example:
	 #+begin_src rust
	   #[derive(Debug)]
	   struct Rectangle {
		   width: u32,
		   height: u32,
	   }

	   impl Rectangle {
		   fn area(&self) -> u32 {
			   self.width * self.height
		   }
	   }

	   fn main() {
		   let rect1 = Rectangle {
			   width: 30,
			   height: 50,
		   };

		   println!(
			   "The area of the rectangle is {} square pixels.",
			   rect1.area()
		   );
	   }
	 #+end_src
   - To define a method we start an impl (implementation) block.
   - You can use &self, &mut self, and self as any other parameter.
*** Automatic reference and dereferencing
	- When you call a method width `object.something()` Rust automatically adds in &, &mut or * so `object` matches the signature of the method.
*** Associated functions
	- A function defined inside an `impl` block, but it doesn't receive self as the first argument is called an associated function.
	- Is called in the program using the namespace of the structure and the `::` operator like we saw in the String::from function.
*** Each structure is allowed to have multiple impl blocks
* Enums and parent matching
** Defining an enum
   #+begin_src rust
	 enum IpAddrKind {
		 v4,
		 v6,
	 }

	 // enum values
	 let four = IpAddrKind::v4;
	 let six = IpAddrKind::v6;

	 // We can associate data (of any type) to an enum like this
	 enum IpAddr {
		 v4(String),
		 v6(String),
	 }
   #+end_src
   - Another example of enum
	 #+begin_src rust
	   enum Message {
		   Quit,
		   Move {x: i32, y: i32},
		   Write(String),
		   ChangeColor(i32,i32,i32),
	   }
	 #+end_src
** The option Enum and its advantages over null values
   #+begin_src rust
	 enum Option<T> {
		 Some(T),
		 None,
	 }

	 let some_string = Some("a string");
	 let absent_number: Option<i32> = None
   #+end_src
   If we use None rather than Some we need to tell Rust what type of Option<T> methods and associated functions
** The `match` control flow operator
   `match`allows you to compare a value against a series of patterns and then execute code base in which pattern matches.
   - Example:
	 #+begin_src rust
	   enum Coin {
		   Penny,
		   Nickel,
		   Dime,
		   Quarter,
	   }

	   fn value_in_cents(coin: Coin) -> u8 {
		   match coin {
			   Coin::Penny => 1,
			   Coin::Nickel => 5,
			   Coin::Dime => 10,
			   Coin::Quarter => 25,
		   }
	   }
	 #+end_src
   - `match` is exhaustive (it forces you to handle every case)
   - For a single pattern matching use `if let`
	 #+begin_src rust
	   if let Some(3) = some_u8_value {
		   println!("three");
	   }

	   // Equivalent to

	   match some_u8_value {
		   Some(3) => println!("three"),
		   _ => (),
	   }
	 #+end_src
* Common Collections
  Rust's standard library includes a number of very useful data structures called collections. Most other data types represent one specific value, but collections can contain multiple values.
  - The data of these collections point to is stored in the heap, which means the amount of data does not need to be known at compile time and can grow or shrink as the program runs.
** Vectors:
   - Type Vec<T>
   - Allows you to store a variable number of values next to each other.
*** Creating a New Vector
	#+begin_src rust
	  let v: Vec<i32> = Vec::new();
	#+end_src
	- It's more common to create a vector width values inside
	- In that case you don't need to annotate the type and Rust provides the `vec` macro
	  #+begin_src rust
		let v = vec![1,2,3];
	  #+end_src
	- Because we've given initial i32 values, Rust can infer the type of v is Vec<i32>, and the type annotation isn't necessary.
*** Updating a Vector
	- You can use the push method
	  #+begin_src rust
		let mut v = Vec::new();

		v.push(5);
		v.push(6);
		v.push(7);
		v.push(8);
	  #+end_src
	- As any variable, if we want to be able to change its value, we need to make it mutable using the mut keyword.
	- The numbers we place inside are all of type i32, and Rust infers this from the data, so we don't need the Vec<i32> annotation.
	- When the vector gets dropped, all f its contents are also dropped, meaning hose integers it holds will be cleaned up.
	- This may seem like a straightforward point but can got a bit more complicated when you start to introduce references to the elements of the vector
*** Reading Elements of Vectors
	- Indexing syntax
	  #+begin_src rust
		let v = vec![1, 2, 3, 4, 5];
		let third: &i32 = &v[2];
		// selects the third element of the vector v
	  #+end_src
	- The get method
	#+begin_src rust
	  let v = vec![1, 2, 3, 4, 5];

	  match v.get(2) {
		  Some(third) => println!("The third element is {}", third),
		  None => println!("There is no third element."),
	  }
	#+end_src
*** Choosing which one to use
	- If you try to index an element of the vector that doesn't exist with the indexing syntax the program will panic
	- Meanwhile using the get method will return `None` and logic can be added to handle what happens when an index out of range is accessed
	- For situations where is normal to access the wrong position like in a user interface where the user must insert the index is better to give one opportunity to introduce the index and telling them what the index range must be it's a better option that panicking
	- For cases where an index out of range implies an error of logic that the program cannot come back from then the best option is to use the indexing syntax
	- The reference rules apply for vectors too
	#+begin_src rust
	  let mut v = vec![1, 2, 3, 4, 5];
	  let first = &v[0];
	  v.push(6);
	  println!("The first element is {}", first);
	#+end_src
	Compiling this code will result in a compile error.
** Strings:
   - Is a collection of characters encoded in UTF-8.
   - String are implemented as a collection of bytes, plus some methods to provide useful functionality when those byte are interpreted as text.
   - What is a String? Usually "string" is referring to the both string slices and `String` slice.
	 - Rust has only one string type in the core language, which is the string slice `str`.
	 - The `String` type, which is provided by Rust's standard library.
*** Creating a New String
	#+begin_src rust
	  let mut s = String::new();
	#+end_src	
*** Creating a String from a string slice
	#+begin_src rust
	  let data = "initial contents";
	  let s = data.to_string();

	  let s = "initial contents".to_string();

	  let s = String::from("initial contents");
	#+end_src
*** Updating a string
	#+begin_src rust
	  let mut s = String::from("foo");
	  s.push_str("bar");

	  // Pushing a character
	  let mut s = String::from("lo");
	  s.push('l');
	#+end_src
**** Concatenation with the + operator or the format! macro
	 #+begin_src rust
	   let s1 = String::from("Hello, ");
	   let s2 = String::from("world!");
	   let s3 = s1 + &s2; // note s1 has been moved here and can no lnger be used
	 #+end_src
	 If we concatenate multiple string multiple strings, the behavior of the + operator gets unwieldy:
	 #+begin_src rust
	   let s1 = String::from("tic");
	   let s2 = String::from("tac");
	   let s3 = String::from("toe");

	   let s = s1 + "-" + &s2 + "-" + &s3;
	 #+end_src
	For complicated string we can use the format! macro.
	#+begin_src rust
	  let s1 = String::from("tic");
	  let s2 = String::from("tac");
	  let s3 = String::from("toe");

	  let s = format!("{}-{}-{}", s1, s2, s3);
	#+end_src
**** Indexing into strings is not allowed
	 #+begin_src rust
	   let s1 = String::from("hello");
	   let h = s1[0];
	 #+end_src
	 Will produce a compilation error.
	 Internal Representation
**** Internal Representation 
	 - A string is a wrapper over Vec<u8>.
**** Slicing String
	 - You can use [] with a range to create a string slice containing particular bytes:
	 #+begin_src rust
	   let hello = "Здравствуйте";
	   let s = &hello[0..2];
	   // Because the first character is 2 bytes long s has the value "З" and it's a string slice
	 #+end_src
**** Methods for iterating over strings
	 - s.chars();
	 #+begin_src rust
	   for c in "नमस्ते".chars() {
		   println!("{}", c);
	   }
	   // will print the following:
	   // न
	   // म
	   // स
	   // ्
	   // त
	   // े
	 #+end_src
	 - s.bytes();
	 #+begin_src rust
	   for b in "नमस्ते".bytes() {
		   println!("{}", b);
	   }
	   // will print:
	   224
	   164
	   // --snip--
	   165
	   135
	 #+end_src
** Hash maps
   Allows you to associate a value with a particular key. It's a particular implementation of the more general data structure called a map.
   - Type HashMap<K, V> stores a mapping of keys of type K to values of type V.
*** Creating a new Hash Map
	#+begin_src rust
	  use std::collections::HashMap;

	  let mut scores = HashMap::new();

	  scores.insert(String::from("Blue"), 10);
	  scores.insert(String::from("Yellow"), 50);
	#+end_src
	Like vectors, hash maps are homogeneous: all of the keys must have the same type and all of the values must have the same type.
**** Creating a hash map by using iterators and the collect method
	 - The `collect` method gathers data into a number of collections types, including HashMap.
	 #+begin_src rust
	   use std::collections::HashMap;

	   let teams = vec![String::from("Blue"), String::from("Yellow")];
	   let initial_scores = vec![10, 50];

	   let mut scores: HashMap<_, _> = teams.into_iter().zip(initial_scores.into_iter()).collect();
	   // zip creates a vector of tuples where "Blue" is paired with 10, and so forth.
	   // then the collect method turns that vector of tuples into a hash map
	   // The type annotation HashMap<_, _> is needed because it's possible
	   // to collect into many different data structures and Rust doesn't
	   // know which you want unless you specify. 
	 #+end_src
*** Hash maps and ownership
	For types that implement the Copy trait, like i32, the values are copied into the hash map. For owned values like String, the values are moved and the hash map will be the owner of those values.
*** Accessing values in a hash map
	We can get a value out of the hash map by providing its key to the get method.
	#+begin_src rust
	  use std::collections::HashMap;

	  let mut scores = HashMap::new();

	  scores.insert(String::from("Blue"), 10);
	  scores.insert(String::from("Yellow"), 50);

	  let team_name = String::from("Blue");
	  let score = scores.get(&team_name);
	#+end_src
	The method get returns an Option<&V>:
	- If the value associated to the key doesn't exist the get returns None
	- Otherwise returns Some(&value), in this case Some(&10).

	We can iterate through over each key/value pair in a hash map in a similar manner as we do with vectors, using a for loop:
	#+begin_src rust
	  use std::collections::HashMap;

	  let mut scores = HashMap::new();

	  scores.insert(String::from("Blue"), 10);
	  scores.insert(String::from( "Yellow" ), 50);

	  for (key, value) in &scores {
		  println!("{}: {}", key, value);
	  }
	#+end_src
*** Updating a HashMap
	- Overwriting a Value
	  Use the `insert` method.
	#+begin_src rust
	  fn main() {
		  use std::collections::HashMap;

		  let mut scores = HashMap::new();

		  scores.insert(String::from("Blue"), 10);
		  scores.insert(String::from("Blue"), 25);

		  println!("{:?}", scores);
	  }

	#+end_src
	- Only inserting a Value If the Key Has no Value
	  Use the `entry` method to get the entry of the given key in the map and `or_insert` method to insert if the element doesn't exist.
	#+begin_src rust
	  fn main() {
		  use std::collections::HashMap;

		  let mut scores = HashMap::new();
		  scores.insert(String::from("Blue"), 10);

		  scores.entry(String::from("Yellow")).or_insert(50);
		  scores.entry(String::from("Blue")).or_insert(50);

		  println!("{:?}", scores);
	  }
	#+end_src
	- Updating a Value Based on the Old Value
	  The `or_insert` method returns a mutable reference to the value
	#+begin_src rust
	  fn main() {
		  use std::collections::HashMap;

		  let text = "hello world wonderful world";

		  let mut map = HashMap::new();

		  for word in text.split_whitespace() {
			  let count = map.entry(word).or_insert(0);
			  *count += 1;
		  }

		  println!("{:?}", map);
	  }
	#+end_src
** More Collections [[https://doc.rust-lang.org/stable/std/collections/index.html][see the documentation]]
* Error Handling 
  Rust groups errors in two major categories: recoverable errors and unrecoverable errors. For a recoverable error such as a file not found error, it's reasonable to report the error to the user and retry the operation. Unrecoverable errors are always symptoms of bugs, like trying to access a location beyond the end of an array.
** For recoverable error Rust has the type `Result<T, E>`
	 - T and E represent generic types
       #+begin_src rust
		 enum Result<T, E> {
			 Ok(T),
			 Err(E),
		 }
	   #+end_src
	 - Result types can be "matched" (use a match) expression to decide what to do in the occurrence of an error `Err`
** And for unrecoverable error the `panic!` macro
	 You're program will print a failure message, unwind and clean up the stack, and then quit. This commonly occurs when a bug of some kind has been detected and it's not clear to the programmer how to handle the error.
	 - To make a program panic call the macro
       #+begin_src rust
		 fn main() {
			 panic!("crash and burn");
		 }
       #+end_src
* Generic Data Types
  -  Generics are abstract stands-ins for concrete types or other properties.
  -  We can use generics to create definitions for items like functions signatures or structs, which we can then use with many different concrete data types.
** In a Function's Signature
   - When we have to have to place the type name declaration inside angle brackets <>, between the name of the function and the parameter list.
   #+begin_src rust
	 fn largest<T>(list: &[T]) -> T {}
   #+end_src
** In Struct Definition
   - We can also define structs to use a generic type parameter in one or more fields using the <> syntax.
   #+begin_src rust
	 struct Point<T> {
		 x: T,
		 y: T,
	 }

	 fn main() {
		 let integer = Point { x: 5, y: 10 };
		 let float = Point { x: 1.0, y: 4.0 };
	 }
   #+end_src
** In Enum Definitions
   - In the same way as in structs
   #+begin_src rust
	 enum Option<T> {
		 Some(T),
		 None,
	 }
   #+end_src
** In Method Definition
   - We have to specify the name of the abstract type in two places:
	 - After the `impl` keyword
	 - And after the name of the struct or enum that uses the generic
   #+begin_src rust
	 struct Point<T> {
		 x: T,
		 y: T,
	 }

	 impl<T> Point<T> {
		 fn x(&self) -> &T {
			 &self.x
		 }
	 }

	 fn main() {
		 let p = Point { x: 5, y: 10 };

		 println!("p.x = {}", p.x());
	 }
   #+end_src

* Traits
  - In a lot of other programming languages this same feature is called interfaces.
  - Trait definitions are a way to group method signatures together to define a set of behaviors necessary to accomplish some purpose.
  - To define a trait use the `trait` keyword.
  #+begin_src rust
	pub trait Summary {
		fn summarize(&self) -> String;
	}
  #+end_src

** Implementing a Trait on a Type
   #+begin_src rust
	 pub struct NewsArticle {
		 pub headline: String,
		 pub location: String,
		 pub author: String,
		 pub content: String,
	 }

	 impl Summary for NewsArticle {
		 fn summarize(&self) -> String {
			 format!("{}, by {} ({})", self.headline, self.author, self.location)
		 }
	 }

	 pub struct Tweet {
		 pub username: String,
		 pub content: String,
		 pub reply: bool,
		 pub retweet: bool,	
	 }

	 impl Summary for Tweet {
		 fn summarize(&self) -> String {
			 format!("{}: {}", self.username, self.content)
		 }
	 }
   #+end_src
  
** Default Implementations
   Sometimes it's useful to have default for some or all of the methods in a trait instead of requiring implementation for all methods on every type.
   #+begin_src rust
	 pub trait Summary {
		 fn summarize(&self) -> String {
			 String::from("(Read more...)")
		 }
	 }
   #+end_src
* Lifetimes
  In Rust every reference has a lifetime, which is the scope for which that reference is valid.
  - Most of the time lifetimes are implicit and inferred.
  - Generic lifetimes parameters are used for the compiler to ensure that a reference will definitely be valid.

  #+begin_src rust
	&i32        // a reference
	&'a i32     // a reference with an explicit lifetime
	&'a mut i32 // a mutable reference with an explicit lifetime
  #+end_src
** Lifetime Annotation in Function Signature
   As with generic type parameters, we need to declare generic lifetime parameter inside angle brackets between the function name and the parameter list
   #+begin_src rust
	 fn main() {
		 let string1 = String::from("abcd");
		 let string2 = "xyz";

		 let result = longest(string1.as_str(), string2);
		 println!("The longest string is {}", result);
	 }

	 fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
		 if x.len() > y.len() {
			 x
		 } else {
			 y
		 }
	 }
   #+end_src
   The function signature now tells Rust that for some lifetime 'a. the function takes two parameters, both of which live at least as long as lifetime 'a. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime 'a. In practice, it means that the lifetime of the reference returned by the longest function is the same as the smaller of the lifetimes of the references passed in. These constraints are what we want Rust to enforce.
** Lifetime Elision
   The patterns programmed into Rust's analysis of references are called the lifetime elision rules. These aren't rules for programmers to follow; they're a set of particular cases that the compiler will consider, and if your code fits these cases, you don't need to write the lifetimes explicitly.
*** The First Rule
	Each parameter that is a reference gets its own lifetime parameter.
	In other words, a function with one parameter gets one lifetime parameter gets one lifetime parameter: fn foo<'a>(x: &'a i32); a function with two parameters gets two separate lifetimes parameters: fn foo<'a, 'b>(x: &'a i32, y: &'b i32); and so on
*** The Second Rule
	If there is exactly one input lifetime parameter, that lifetime is assigned to the all output lifetime parameters: fn foo<'a>(x: &'a i32) -> &'a i32
*** The Third Rule
	If there are multiple input lifetime parameters, but one of them is &self or &met self because this is a method the lifetime of self is assigned to all output lifetime parameters.
** Lifetime Annotation in Struct Definition
   #+begin_src rust
	 struct ImportantExcerpt<'a> {
		 part: &'a str,
	 }
   #+end_src
** Lifetime Annotation in Method Definition
   #+begin_src rust
	 impl<'a> ImportantExcerpt<'a> {
		 fn level(&self) -> i32 {
			 3
		 }
	 }
   #+end_src
** The Static Lifetime
   One special lifetime we need to discuss is 'static, which means that this reference can live for the entire duration of the program. All string literals have the 'static lifetime, which we can annotate as follows:
   #+begin_src rust
	 let s: &'static str = "I have a static lifetime.";
   #+end_src
   The text of this string is stored directly in the program's binary, which is always available. Therefore, the lifetime of all string literals is 'static.
   You might see suggestions to use the 'static lifetime in error messages, But before specifying 'static as the lifetime for a reference, think about whether the reference actually lives the entire lifetime of your program or not. You might consider whether you want in to live that long, even if it could. Most of the time, the problem results from attempting to create a dangling or a mismatch f the available reference of the available lifetimes. In such cases, the solution is fixing those problems, not specifying the 'static lifetime.
** Generic Type Parameters, Trait Bounds, and Lifetimes Together
   #+begin_src rust
	 use std::fmt::Display;

	 fn longest_with_an_announcement<'a, T> (
		 x: &'a str,
		 y: &'a str,
		 ann: T,
	 ) &'a str
	 where
		 T: Display,
	 {
		 println!("Announcement! {}", ann);
		 if x.len() > y.len() {
			 x
		 } else {
			 y
		 }
	 }

   #+end_src
* Managing Growing Projects with Packages, Crates and Modules
  - *Packages*: A cargo feature that lets you build, test and share crates
  - *Crates*: A tree of modules that produces a library or executable
  - *Modules* and *use*: Let you control the organization, scope and privacy of paths
  - *Path*: A way of naming an item, such as a struct, function, or module
** Defining Modules to Control Scope and Privacy
   - Use the keyword `mod` to create a module.
   - The `use` keyword that brings a path into scope.
   - The `pub` keyword to make items public
   - The `as` keyword
*** Modules
	- Let us organize the code within a crate into groups for readability and easy reuse.
	- Also control the privacy of items
	  - An item can be used by outside code if it's public
	  - And it can't if it's private
	- Example:
	#+begin_src rust
	  mod front_of_house {
		  mod hosting {
			  fn add_to_waitlist() {}

			  fn seat_at_table() {}
		  }

		  mod serving {
			  fn take_order() {}

			  fn serve_order() {}

			  fn take_payment() {}
		  }
	  }
	#+end_src
	- Tree structure of this module
	#+begin_src sh
	  crate
	   └── front_of_house
		   ├── hosting
		   │   ├── add_to_waitlist
		   │   └── seat_at_table
		   └── serving
			   ├── take_order
			   ├── serve_order
			   └── take_payment
	#+end_src
** Path for Referencing to an Item in the Module Tree
   Both absolute and relative paths are followed by one or more identifiers separated by double colons (::).
*** A Absolute path
	Starts from a crate root by using a crate name or literal crate.
*** A Relative Path
	Starts from the current module and uses self, super, or an identifier in the current module
*** Example
	#+begin_src rust
	  mod front_of_house {
		  mod hosting {
			  fn add_to_watinglist() {}
		  }
	  }

	  pub fn eat_at_restaurant() {
		  // Absolute Path
		  crate::front_of_house::hosting::add_to_waitlist();

		  // Relative Path
		  front_of_house::hosting::add_to_waitlist();
	  }
	#+end_src
** Exposing Path with the pub Keyword
   - Everything is private by default
	 #+begin_src rust
	   mod front_of_house {
		   pub fn in_front_of_house() {
			   println!("In front of house");
		   }
		   pub mod hosting {
			   fn add_to_waitlist() {
				   super::in_front_of_house();
				   println!("add to wait list");
			   }
		   }
	   }
	   fn main() {
		   println!("Hello, world!");
		   crate::front_of_house::hosting::add_to_waitlist();
		   front_of_house::in_front_of_house();
	   }
	 #+end_src
	 This code will give an error because `add_to_waitlist` is private.
   - Use the `pub` keyword to make any element public.
   - A module define at the same level is immediately accessible but every module after that needs to be public to be accessible
	 #+begin_src rust
	   mod front_of_house {
		   pub fn in_front_of_house() {
			   println!("In front of house");
		   }
		   pub mod hosting {
			   pub fn add_to_waitlist() {
				   super::in_front_of_house();
				   println!("add to wait list");
			   }
		   }
	   }

	   fn main() {
		   println!("Hello, world!");
		   crate::front_of_house::hosting::add_to_waitlist();
		   front_of_house::in_front_of_house();
	   }
	 #+end_src
	 The module `front_of_house` doesn't need to be public to be access in the main function because they are at the same level, but the inner modules and function do.
   - Functions have to be made public explicitly to be used in outside modules, but all the inside modules can use private functions defined in a parent module.
   - You can use super to refer to parent modules.
** Making Structs and Enums Public
   We can also use pub to designate structs and enums as public,  but that doesn't make the fields immediately public each field can be private or public
	 #+begin_src rust
	   mod back_of_house {
		   pub struct Breakfast {
			   pub toast: String, // public
			   seasonal_fruit: String, // private and cannot be accessed outside the module
		   }

		   impl Breakfast {
			   pub fn summer(toast: &str) -> Breakfast {
				   Breakfast {
					   toast: String::from(toast),
					   seasonal_fruit: String::from("peaches"),
				   }
			   }
		   }
	   }

	   pub fn eat_at_restaurant() {
		   let mut meal = back_of_house::Breakfast::summer("Rye");
		   meal.toast = String::from("Wheat");
		   println!("I'd like {} toast please", meal.toast);
	   }
	 #+end_src
** Bringing Paths into Scope with the use Keyword
   - Using the `use` keyword
	 #+begin_src rust
	   mod front_of_house {
		   pub mod hosting {
			   pub fn add_to_waitlist(){}
		   }
	   }

	   use crate::front_of_house::hosting;

	   pub fn eat_at_restaurant() {
		   hosting::add_to_waitlist();
		   hosting::add_to_waitlist();
		   hosting::add_to_waitlist();
	   }
	 #+end_src

   - For convention and also for convenience reasons it's recommended to write the use path until the parent module of the function or type that we want to use, as we can see in the following example that allow to differentiate between the two Result type.
	 #+begin_src rust
	   fn main() {
	   use std::fmt::Result;
	   use std::io::Result;

	   fn function1() -> fmt::Result {
		   // --snip--
		   Ok(())
	   }

	   fn function2() -> io::Result<()> {
		   // --snip--
		   Ok(())
	   }
	   }
	 #+end_src
** Providing New Names with the `as` Keyword
   #+begin_src rust
	 use std::fmt::Result;
	 use std::io::Result as IoResult;

	 fn function1() -> Result {
	
	 }

	 fn function2() -> IoResult {
	
	 }
   #+end_src
   In the second use statement, we chose the new name IoResult for the std::io::Result type which won't conflict with the Result from std::fmt.
** Re-expoting Names with `pub use`
   When we bring a name into scope with the use keyword, the name available in the new scope is private. To enable the code that calls our code to refer to that name as if it had been defined in that code's scope.
   #+begin_src rust
	 mod front_of_house {
		 pub mod hosting {
			 pub fn add_to_waitlist() {
				 // some code	
			 }
		 }
	 }

	 pub use crate::front_of_house::hosting;

	 pub fn eat_at_retaurant() {
		 hosting::add_to_waitlist();
		 hosting::add_to_waitlist();
		 hosting::add_to_waitlist();
	 }
   #+end_src
   By using `pub use`, external code can now call the add_to_waitlist function using hosting::add_to_waitlist.
** Using External Packages
   Add to the Cargo.toml file the entry of the external package under the dependencies tag.
   To use the external package `rand` in our project we do as follows:
   #+begin_src conf
	 [dependencies]
	 rand = "0.5.5"
   #+end_src
   Then to bring the rand definition into the scope of our package, we added a use line starting with the name of the package, rand.
   #+begin_src rust
	 use rand::Rng;

	 fn main() {
		 let secret_number = rand::thread_rng().gen_range(1, 101);
	 }
   #+end_src
   Members of the Rust community have made many packages available at crates.io, and pulling any of them into your package involves these same steps: listing them in your package’s Cargo.toml file and using use to bring items into scope.
** Using Nested Paths to Clean Up Large use Lists
   #+begin_src rust
	 use std::cmp::Ordering;
	 use std::io;
   #+end_src
   Becomes
   #+begin_src rust
	 use std::{cmp::Ordering, io};
   #+end_src
   And
   #+begin_src rust
	 use std::io;
	 use std::io::Write;
   #+end_src
   Becomes
   #+begin_src rust
	 use std::io::{self, Write}
   #+end_src
** The Glob Operator
   If you want to bring all public items defined in a path into scope, we can specify that oath followed by `*`, the glob operator:
   #+begin_src rust
	 use std::collections::*;
   #+end_src
   This use statement brings all public items defined in std::collections into the current scope.
   - Be careful when using the glob operator! Glob can make it harder to tell what names are in scope and where a name used in your program was defined.
   - The glob operator is often used when testing to bring everything under test into the `tests` module;
** Separating Modules into Different Files
   - Create a file with the same name of the module that you want to move to its own file.
   - Add the keyword mod followed by the path to that module to the file that is the root of the crate, i.e., main.rs for a binary crate or lib.rs for a library crate.
	 Suppose you want to move the module front_of_house to it's own file:
	 The content of src/lib.rs (the root of these crate) becomes as follows.
	 #+begin_src rust
	   mod front_of_house;

	   pub use crate::front_of_house::hosting;

	   pub fn eat_at_restaurant() {
		   hosting::add_to_waitlist();
		   hosting::add_to_waitlist();
		   hosting::add_to_waitlist();
	   }
	 #+end_src
	 And then you need to be create the file src/front_of_house.rs and put the content of the front_of_house there.
	 The content of the src/front_of_house.rs:
	 #+begin_src rust
	   pub mod hosting {
		   pub fn add_to_waitlist() {}
	   }
	 #+end_src
   - To move the hosting module to its own file you need to add `mod hosting;` to the beginning of the file src/front_of_house.rs and create the folder src/front_of_house/ and place the content of the hosing module inside a file called hosting in the path src/front_of_house/
	 Content of the file src/front_of_house/hosting.rs
	 #+begin_src rust
	   pub fn add_to_wailist() {}
	 #+end_src
   - The tree of the src/ directory now looks like this:
	 #+begin_src sh
	 $ tree src
	   src
	   ├── front_of_house
	   │   └── hosting.rs
	   ├── front_of_house.rs
	   └── lib.rs
	 #+end_src
* Writing automated tests
  - At it's simplest, a test in Rust is a function that's annotated with the `test` attribute.
	- Attributes are metadata about pieces of code; one example is derive
  - To change a function into a test function, add #[test] on the line before `fn`.
  - When you run a test with the `cargo test` command, Rust builds a test runner binary that runs the functions annotated with the test attribute and reports on whether each test function passes or fails
  - By default when you create a library crate using `cargo new project -lib` cargo creates a lib.rs file in the src directory with the content:
	#+begin_src rust
	  #[cfg(test)]
	  mod tests {
		  #[test]
		  fn it_works() {
			  assert_eq!(2 + 2, 4);
		  }
	  }
	#+end_src
	When you run cargo test the function `it_works` is executed and the result is shown in the output.
	#+begin_src sh
	  $ cargo test
		 Compiling adder v0.1.0 (file:///projects/adder)
		  Finished test [unoptimized + debuginfo] target(s) in 0.57s
		   Running target/debug/deps/adder-92948b65e88960b4

	  running 1 test
	  test tests::it_works ... ok

	  test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out

		 Doc-tests adder

	  running 0 tests

	  test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
	#+end_src
  - A test fails when it panics
  - The macro `assert!`, `assert_eq!` and `assert_ne!` panic when the conditions are not met
	- assert!(predicate) panics when the predicate is false.
	- assert_eq!(a, b) (assert equal) panics when `a` is different from `b`.
	- assert_ne!(a, b) (assert not equal) panics when `a` is equal to `b`.
** Checking for Panic with `should_panic`
   - If you what to check that a function is panicking when it should you can use the should_panic attribute in the line between the attribute test and fn
	 #+begin_src rust
	   #[cfg(test)]
	   mod tests {
		   use super::*;

		   #[test]
		   #[should_panic]
		   fn greater_than_100() {
			   Guess::new(200);
		   }
	   }
	 #+end_src

   - To make the error easier to find you can specify the error that is displayed you can add the message to the should_panic attribute
	 #+begin_src rust
	   #[cfg(test)]
	   mod tests {
		   use super::*;

		   #[test]
		   #[should_panic(expected = "Guess value must be less than or equal to 100")]
		   fn greater_than_100() {
			   Guess::new(200);
		   }
	   }
	 #+end_src
** Using Result<T, E> in Tests
   - Instead of writing tests that panic when they fail we can write test that use Result<T, E>
	 #+begin_src rust
	   #[cfg(test)]
	   mod tests {
		   #[test]
		   fn it_works() -> Result<(), String> {
			   if 2 + 2 == 4 {
				   Ok(())
			   } else {
				   Err(String::from("two plus two does not equal four"))
			   }
		   }
	   }
	 #+end_src
   - You can’t use the #[should_panic] annotation on tests that use Result<T, E>. Instead, you should return an Err value directly when the test should fail.
** Controlling How Tests Are Run
   Just as cargo run compiles your code and then runs the resulting binary, cargo test compiles your code in test mode and runs the resulting code in test mode and runs the resulting test binary.
   - When you run the command cargo test some command line options go to cargo test, and some go to the resulting test binary. To separate these two types of arguments, you list the arguments that go to cargo test followed by the separator -- and then the ones that go to the test binary.
	 - Running cargo test --help displays the potions you can use with cargo test, and running cargo test -- --help displays the options you can use after the separator --.
*** Running Tests in Parallel or Consecutively
	- By default tests run in parallel using threads.
	- This can be overwritten by using cargo test -- --test-threads=1 which runs all the tests in only one thread (consecutively).
*** Showing Function Output
	- By default the output of the functions ran by the test are captured
	- This can be overwritten by using: cargo test -- --show-output
*** Running Subset of Test by Name
	- You can run a single test by specifying the name of the function after the cargo test
	  - Ex: cargo test test_name, run only the test `test_name`
	- Filtering to run multiple modules by specifying a partial name that matches more than one test.
	  - Ex: imagine we have a test name add_three_and_two and another add_two_and_two by running cargo test add both test are going to run.
*** Ignoring Tests Unless Specifically Requested
	- Use the ignore attribute
	  #+begin_src rust
		#[test]
		fn it_works() {
			assert_eq!(2 + 2, 4);
		}

		#[test]
		#[ignore]
		fn expensive_test() {
			// code that takes an hour to run
		}
	  #+end_src
	  Now when you run cargo test `expensive_test` it's gonna be ignored and it's not gonna be executed.

	- To run the ignored test you have to specify cargo test -- --ignored
*** Read more about test organization in [[https://doc.rust-lang.org/stable/book/ch11-03-test-organization.html][Chapter 11.3.]] of the book
* Functional Language Features: Iterators and Closures
** Closures: Anonymous Functions that can Capture Their Environment
   Rust's closures are anonymous functions you can save in variables or pass to other functions. You can create the closure in one place and call the closure to evaluate it in a different context.
   Closures in Rust, also called lambda expression or lambdas, are functions that can capture the enclosing environment. For example, a closure that captures the x variable:
   #+begin_src rust
	 let closure = |val| val + x
   #+end_src
   - Calling a closure it's exactly like calling a function. However, both input and return types can be inferred and input variable must be specified.
   - Closures use || instead of () around input variables.
   - Optional body delimitation ({}).
   - The ability to capture the outer environment variables.
	 #+begin_src rust
	   fn main() {
		   // Increment via closures and functions.
		   fn  function            (i: i32) -> i32 { i + 1 }

		   // Closures are anonymous, here we are binding them to references
		   // Annotation is identical to function annotation but is optional
		   // as are the `{}` wrapping the body. These nameless functions
		   // are assigned to appropriately named variables.
		   let closure_annotated = |i: i32| -> i32 { i + 1 };
		   let closure_inferred  = |i     |          i + 1  ;

		   let i = 1;
		   // Call the function and closures.
		   println!("function: {}", function(i));
		   println!("closure_annotated: {}", closure_annotated(i));
		   println!("closure_inferred: {}", closure_inferred(i));

		   // A closure taking no arguments which returns an `i32`.
		   // The return type is inferred.
		   let one = || 1;
		   println!("closure returning one: {}", one());

	   }
	 #+end_src
   - Closures are inherently flexible and will do what the functionality requires to make the closure work without annotation.
   - This allows captured to flexibly adapt to use case, sometimes moving and sometimes borrowing.
   - Closures can capture variables: by reference: &T, by mutable reference: &mut T and by value: T.
   - They preferentially capture variables by reference and only go lower when required.
** As Input Parameters
   While Rust chooses how to capture variables on the fly mostly without type annotation, this ambiguity is not allowed when writing functions. Then taking a closure as an input parameter, the closure's complete type must be annotated using one of a few traits. In order of decreasing restriction, they are:
   - Fn: the closure captures by reference (&T).
   - FnMut: the closure captures by mutable reference (&mut T).
   - FnOnce: the closure captures by value (T).
	 #+begin_src rust
	   fn apply<F>(f: F) where
		   F: FnOnce() {
		   f()
	   }

	   fn apply_to_3<F>(f: F) -> i32 where
		   F: Fn(i32) -> i32 {
		   f(3)
	   }
	 #+end_src
* Smart Pointers
  A pointer is a general concept for a variable that contains an address in memory. This address refers to, or "points at", some other data. The most common kind of pointer of pointer in Rust is a reference.
** References 
   - References are indicated by the by the & symbol and borrow the value they point to.
   - They don't have any special capability other that referring to data.
   - They don't have any overhead.
   - They are the kind of pointer we use more often.
** Smart Pointers
   - They are data structures that act like a pointer.
   - They also have additional metadata and capabilities.
   - In many cases smart pointers own the data they point to, in contrast to references which only borrow data.
   - Examples of smart pointers: Strings and Vec<T>.
	 - Both of these own some memory and allow to manipulate it.
	 - They also have metadata (such as their capacities) and extra capabilities or guarantees (such as with String ensuring its data will always be a valid UTF-8).
   - Smart pointers are usually implementing using structs.
   - Smart pointers implement the Deref and Drop traits.
   - The Deref trait allows an instance of the smart pointer to behave like a reference so you can write a code that works with either references or smart pointers.
   - The Drop trait allows you to customize the code that is run when an instance of the smart pointer goes out of scope.
   - The most common smart pointers in the standard library are:
	 - Box<T> for allocating values on the heap.
	 - Rc<T>, a reference counting type that enables multiple ownership.
	 - Ref<T> and RefMut<T>, accessed through RefCell<T>, a type that enforces the borrowing rules at runtime instead of compile time
** Using Box<T> to Point to Data on the Heap
   Boxes don't have performance overhead, other than storing their data on the heap instead of on the stack. But they don't have many extra capabilities either. You'll use them most often in these situations:
   - When you have a type whose size can't be known at compile time and you want to use a value of that type in a context that requires an exact size.
   - When you have a large amount of data and you want to transfer ownership but ensure the data won't be copied when you do so.
   - When you want own a value and you care only that it's a type that implements a particular trait rather than being of a specific type.
** Using a Box<T> to Store Data on the Heap
   #+begin_src rust
	 fn main() {
		 let b = Box::new(5);
		 println!("b = {}", b);
	 }
   #+end_src
   We define the variable b to have the value of a Box that points to the value 5, which is allocated on the heap. This program will print `b = 5`.
** Enabling Recursive Types with Boxes
   At compile time, Rust needs to know how much space a type takes up. One type whose size can't be known at compile time s a recursive type, where a value can have a s part of itself another value of the same type. Because nesting of values could theoretically continue infinitely, Rust doesn't know how much space a value of a recursive type needs. However, boxes have a known size, so by inserting a box in a recursive type definition, you can have recursive types.
*** Cons List
	#+begin_src rust
	  enum List {
		  Cons(i32, List),
		  Nil,
	  }

	  fn main() {
		  let list = Cons(1, Cons(2, Cons(3, Nil)));
	  }
	#+end_src
	This code doesn't compile because Rust cannot determine the size of the list at compile time. In the compilation error we get:
	#+begin_src sh
	  $ cargo run
		 Compiling cons-list v0.1.0 (file:///projects/cons-list)
	  error[E0072]: recursive type `List` has infinite size
	   --> src/main.rs:1:1
		|
	  1 | enum List {
		| ^^^^^^^^^ recursive type has infinite size
	  2 |     Cons(i32, List),
		|               ---- recursive without indirection
		|
		= help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `List` representable

	  error[E0391]: cycle detected when processing `List`
	   --> src/main.rs:1:1
		|
	  1 | enum List {
		| ^^^^^^^^^
		|
		= note: ...which again requires processing `List`, completing the cycle
		= note: cycle used when computing dropck types for `Canonical { max_universe: U0, variables: [], value: ParamEnvAnd { param_env: ParamEnv { caller_bounds: [], reveal: UserFacing, def_id: None }, value: List } }`

	  error: aborting due to 2 previous errors

	  Some errors have detailed explanations: E0072, E0391.
	  For more information about an error, try `rustc --explain E0072`.
	  error: could not compile `cons-list`.

	  To learn more, run the command again with --verbose.
	#+end_src
	Rust cannot figure out how much space to allocate for recursively defined types, so the compiler gives the error in Listing 15-3. But the error does include this helpful suggestion:
	#+begin_src sh
		= help: insert indirection (e.g., a `Box`, `Rc`, or `&`) at some point to make `List` representable
	#+end_src
	Using boxes Rust can allocate memory because Box<T> is a pointer and Rust always knows how much space a Box<T> needs: a pointer's size doesn't change based on the amount of data it's pointing to.

	#+begin_src rust
	  enum List {
		  Cons(i32, Box<List>),
		  Nil,
	  }

	  use crate::List::{Cons, Nil};

	  fn main() {
		  let list = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));
	  }
	#+end_src

	Defining `List` like this does compile.
** Treating Smart Pointers Like Regular References with the Deref Trait
   Implementing the Deref trait allows you to customize the behavior of the dereference operator, *. By implementing Deref in such a way that a smart pointer can be treated like a regular reference, you can write code that operates on references and use that code with smart pointers too.
*** Following the Pointer to the Value with the Dereference Operator
	A regular reference is a type of pointer, and one way to think of a pointer is as an arrow to a value stored somewhere else. In Listing 15-6, we create a reference to an i32 value and then use the dereference operator to follow the reference to the data:
	#+begin_src rust
	  fn main() {
		  let x = 5;
		  let y = &x;

		  assert_eq!(5, x);
		  assert_eq!(5, *y);
	  }
	#+end_src
*** Using Box<T> Like a Reference
	We can rewrite the code above to use a Box<T> instead of reference; the dereference operator will work as shown above.
	#+begin_src rust
	  fn main() {
		  let x = 5;
		  let y = Box::new(5);

		  assert_eq!(5, x);
		  assert_eq!(5, *y);
	  }
	#+end_src
*** Defining Our Own Smart Pointer
	Let's build a smart pointer similar to the Box<T> type provided by the standard library to experience how smart pointers behave differently from references by default
	#+begin_src rust
	  struct MyBox<T>(T);

	  impl<T> MyBox<T> {
		  fn new(x: T) -> MyBox<T> {
			  MyBox(x)
		  }
	  }

	  fn main() {
		  let x = 5;
		  let y = MyBox::new(x);

		  assert_eq!(5, x);
		  assert_eq!(5, *y);
	  }
	#+end_src
	This code won't compile and in the error we can see that it's because the type `MyBox<{integer}>` cannot be dereferenced
*** Treating a Type Like a Reference by Implementing the Deref Trait
	#+begin_src rust
	  use std::ops::Deref;

	  impl<T> Deref for MyBox<T> {
		  type Target = T;

		  fn deref(&self) -> &T {
			  &self.0
		  }
	  }
	#+end_src
	Now the code will compile and the work as expected.
	When we entered *y in the code above Rust actually ran this code
	#+begin_src rust
	  *(y.deref())
	#+end_src
	Rust substitutes the * operator with a call to the deref method and then a plain reference so we don't have to think about whether or not we need to call the deref method.
	- This feature lets us write code that functions identically whether we have a regular reference or a type that implements Deref.
*** How Deref Coercion Interacts with Mutability
	Similar to how you use the Deref trait to override the * operator on immutable references, you can use the DerefMut trait to override the * operator on mutable references.
	Rust does deref coercion when it finds types and trait implementations in three cases:
	- From &T to &U when T: Deref<Target=U>
	- From &mut T to &mut U when T: DerefMut<Target=U>
	- From &mut T to &U when T: Deref<Target=U>
*** Running Code on Cleanup with the Drop Trait
	- The Drop Trait lets us customize what happens when a value is about to go out of scope.
	- You can provide an implementation for the Drop trait on any type, not only smart pointers.
	- The drop method is called automatically when a variable of that type is going out of scope.
*** Dropping a Value Early with std::mem::drop
	- The drop method can't be called by your code and the automatic call of drop can't be disabled.
	- For cases where you want to clean up a value early you can call the std::mem::drop function.
	  #+begin_src rust
		struct CustomSmartPointer {
			data: String,
		}

		impl Drop for CustomSmartPointer {
			fn drop(&mut self) {
				println!("Dropping CustomSmartPointer with data `{}`!", self.data);
			}
		}

		fn main() {
			let c = CustomSmartPointer {
				data: String::from("some data"),
			};
			println!("CustomSmartPointer created.");
			drop(c);
			println!("CustomSmartPointer dropped before the end of main.");
		}
	  #+end_src
** Rc<T>, the Reference Counted Smart Pointer
   In the majority of cases, ownership is clear: you know exactly which variable owns a given value. However there are cases when a single value might have multiple owners.
   - To enable multiple ownership, Rust has a type called Rc<T>, which is an abbreviation for reference counting.
   - The Rc<T> type keeps track of the number of references to a value which determines whether or not a value is still in use.
*** Using Rc<T> to Share Data
	Let's return to our cons list example. Recall that we defined it using Box<T>. This time we'll create two list that share ownership of a third list. Conceptually, this similar to figure 15-3.
	#+begin_src rust
	  enum List {
		  Cons(i32, Box<List>),
		  Nil,	
	  }

	  use crate::List::{Cons, Nil};

	  fn main() {
		  let a = Cons(5, Box::new(Cons(10, Box::new(Nil))));
		  let b = Cons(3, Box::new(a));
		  let c = Cons(5, Box::new(a));
	  }
	#+end_src
	This code won't compile because when we create the list `b` the list `a` is moved to `b`. So it's impossible to use `a` again to define `c`.

	We can use Rc<T> to make this possible:
	#+begin_src rust
	  enum List {
		  Cons(i32, Rc<List>),
		  Nil,
	  }

	  use crate::List::{Cons, Nil};
	  use std::rc::Rc;

	  fn main() {
		  let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
		  let b = Cons(3, Rc::clone(&a));
		  let c = Cons(4, Rc::clone(&a));
	  }
	#+end_src

	- Rc::clone doesn't make a deep copy of all the data.
	- The call to Rc::clone only increments the reference count, which doesn't take much time.
*** Cloning an Rc<T> Increases the Reference Count
	Let's see how the reference count change as we create and drop references to the Rc<List> in a.
	#+begin_src rust
	  fn main() {
		  let a = Rc::new(Cons(5, Rc::new(Cons(10, Rc::new(Nil)))));
		  println!("count after creating a = {}", Rc::strong_count(&a));
		  println!("count after creating b = {}", Rc::string_conut(&a));
		  {
			  let c Conts(4, Rc::clone(&a));
			  pringln!("cont after creating c = {}", Rc::strong_count(&a));
		  }
		  println!("count after c goes out of scope = {}", Rc::strong_count(&a));
	  }
	#+end_src
	This code prints the following:
	#+begin_src sh
	  $ cargo run
		 Compiling cons-list v0.1.0 (file:///projects/cons-list)
		  Finished dev [unoptimized + debuginfo] target(s) in 0.45s
		   Running `target/debug/cons-list`
	  count after creating a = 1
	  count after creating b = 2
	  count after creating c = 3
	  count after c goes out of scope = 2
	#+end_src
** RefCell<T> and the Interior Mutability Pattern
   Interior mutability is a design pattern in Rust that allows you to mutate data even when there are immutable references to that data; normally, this action is disallowed by the borrowing rules. To mutate data, the pattern uses `unsafe` cod inside a data structure to vend Rust's usual rules that govern mutation and borrowing.
*** Enforcing Borrowing rules with RefCell<T>
	Unlike Rc<T>, the Refcell<T> type represents single ownership over data it holds
	- RefCell enforces the borrowing rules at runtime instead than at compile time
	- Instead of not compiling when the borrowing rules are not followed the program will panic
	- This is useful because sometimes the sometimes a program can be correct and the borrow checker cannot know that they are correct.
	- Similar to Rc<T>, RefCell<T> is only for use in single-threaded scenarios and will give you a compile-time error if you try using it in a multi-threaded context. We'll talk about how to get the functionality of RefCell<T>
*** Recap of the Reasons to Use Box<T>, Rc<T> or RefCell<T>
	- Rc<T> enables multiple owners of the same data; Box<T> and RefCcell<T> have single owners.
	- Box<T> allows immutable or mutable borrows checked at compile time; Rc<T> allows only immutable borrows checked at compile time; RefCell<T> allows immutable of mutable borrows checked at runtime
	- Because RefCell<T> allows mutable borrows checked at runtime, you can mutate the value inside the RefCell<T> even when the RefCell<T> is immutable.
*** Interior Mutability: A Mutable Borrow to an Immutable Value
	A consequence of the borrowing rules is that when you have an immutable value, you can't borrow it mutably. For example, this code won't compile
	#+begin_src rust
	  fn main() {
		  let x = 5;
		  let y = &mut x;
	  }
	#+end_src
	- However there are cases in which it would be useful for a value to mutate itself in it's methods but appear immutable to other code.
	- RefCell<T> serves that purpose read [[https://doc.rust-lang.org/stable/book/ch15-05-interior-mutability.html#a-use-case-for-interior-mutability-mock-objects][A Use Case for Interior Mutability: Mock Objects]] for a practical example.
*** Keeping Track of Borrows at Runtime with RefCell<T>
	- When creating immutable and mutable references, we use the & and mut syntax, respectively.
	- With RefCell<T>, we use the borrow and `borrow` and `borrow_mut` methods, which are part of the safe API that belongs to RefCell<T>.
	- The `borrow` method returns the smart pointer Ref<T>
	- The `borrow_mut` method returns the smart pointer type RefMut<T>
	- Ref<T> and RefMut<T>, both implement the Deref trait so they can be used as regular references
	- The RefCell<T> keeps track of how many Ref<T> and RefMut<T> smart pointers are currently active
	- Just like the compile-time borrowing rules, RefCell<T> lets us have many immutable borrows or one mutable borrow t any point in time
	- If we try to violate these rules, rather than getting a compiler error as we would with references, the implementation will panic at runtime.
*** Having Multiple Owners of Mutable Data by Combining Rc<T> and RefCell<T>
	A common way to use RefCell<T> is in combination with Rc<T>. Recall that Rc<T> lets you have multiple owners of some data, but in only gives immutable access to that data. If you have an Rc<T> that holds a RefCell<T>, you can get a value that can have multiple owners and that you can mutate! Let's see the example of the Cons list
	#+begin_src rust
	  #[derive(Debug)]
	  enum List {
		  Cons(Rc<RefCell<i32>>, Rc<List>),
		  Nil,
	  }

	  use crate::List::{Cons, Nil};
	  use std::cell::RefCell;
	  use std::rc::Rc;

	  fn main() {
		  let value = Rc::new(RefCell::new(5));

		  let a = Rc::new(Cons(Rc::clone(&value), Rc::new(Nil)));

		  let b = Cons(Rc::new(RefCell::new(6)), Rc::clone(&a));
		  let c = Cons(Rc::new(RefCell::new(10)), Rc::clone(&a));

		  ,*value.borrow_mut() += 10;

		  println!("a after = {:?}", a);
		  println!("b after = {:?}", b);
		  println!("c after = {:?}", c);
	  }
	#+end_src
	Now we have multiple ownership of the cons list with Rc<T> and we can mutate the values using the RefCell<T> type.
*** Other Types in the Standard Library that Provide Interior Mutability
	- Cell<T>, which is similar to RefCell except that instead of giving references to the inner value, the value is copied in and out of the Cell<T>.
	- Mutex<T>, which offers interior mutability that is safe to use across threads.
	- Check out the standard library docs for more details
** Reference Cycles Can Leak Memory
   Rust's memory safety guarantees makes it difficult but not impossible to accidentally create memory that is never cleaned up (known as a memory leak).
   - Preventing memory leaks entirely is not one of Rust's guarantees.
   - We can see that Rust allows memory leaks by using Rc<T> and RefCell<T>: it's possible to create references where items refer to each other in a cycle. this creates memory leaks because the references count of item in the cycle will never reach 0, and the values will never be dropped.
   - 
